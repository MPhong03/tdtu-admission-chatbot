ENRICHMENT PLANNING (Bước <step>/<max_steps>):

Câu hỏi gốc: "<user_question>"
Main context: <context_count> nodes
Analysis: <analysis_info>
Sample context: <sample_context>

Enrichment targets: <enrichment_targets>

THÔNG TIN HIỆN TẠI:
- Context score hiện tại: <current_context_score>/1.0
- Cải thiện score: <score_improvement>
- Lịch sử scores: <context_score_history>

CÁC ENRICHMENT ĐÃ THỰC HIỆN:
<previous_enrichments>

QUY TẮC ENRICHMENT:
1. Chỉ tạo query khi THỰC SỰ cần thiết
2. Không duplicate với main context
3. Focus vào info gaps cho intent chính
4. Query phải valid theo Neo4j schema
5. **QUAN TRỌNG: Tạo query KHÁC BIỆT với các enrichment trước đó**
6. Nếu enrichment trước trả về 0 kết quả -> đổi hướng tiếp cận hoàn toàn
7. Nếu context score không cải thiện -> thử approach khác (node type, relationship, keywords)
8. Phân tích WHY previous enrichments failed và avoid repeating mistakes
9. Lưu ý quan trọng với học phí:
   - Không cố parse số từ t.content bằng split, filter, hay regex.
   - Không dùng ORDER BY dựa trên giá trị ước lượng học phí.
   - Chỉ cần truy vấn tài liệu học phí (Tuition) kèm tên hệ đào tạo và năm để người dùng đọc so sánh.
   - Dùng ORDER BY p.name để sắp xếp dễ nhìn.

ENRICHMENT SCENARIOS & ADAPTIVE STRATEGIES:

**Khi context score thấp (<0.5):**
- Nếu main query về học phí nhưng thiếu -> Try Scholarship, Document về học phí
- Nếu main query về ngành nhưng thiếu -> Try MajorProgramme, Document về ngành
- Nếu comparison thiếu 1 side -> Complete comparison với approach khác

**Khi previous enrichment failed (0 results):**
- Đổi node type: Major -> MajorProgramme -> Document
- Đổi keywords: từ cụ thể -> từ tổng quát hơn
- Đổi relationship path: direct -> indirect relationships

**Khi context score cải thiện chậm (<0.1 improvement):**
- Thử node type hoàn toàn khác
- Thử relationship pattern khác
- Thử broader keywords hoặc related concepts

**Skip enrichment khi:**
- Main context đã đầy đủ (score >0.75)
- Previous enrichments đã cover đủ info types
- Không liên quan intent chính

QUY TẮC SINH CYPHER:
==== I. SCHEMA ĐỒ THỊ (TÓM TẮT) ====
Nodes:
- Major: Ngành học (VD: Khoa học máy tính).
- Programme: Hệ đào tạo (VD: Tiêu chuẩn, Tiên tiến).
- MajorProgramme: Tổ hợp Major + Programme theo năm.
- Tuition: Tài liệu học phí theo năm và hệ.
- Scholarship: Tài liệu học bổng.
- Document: Các tài liệu khác về trường.
- Year: Đại diện năm học.

Relationships:
- Major-[:HAS_PROGRAMME]->Programme
- Programme-[:HAS_MAJOR]->Major
- MajorProgramme-[:OF_MAJOR]->Major
- MajorProgramme-[:OF_PROGRAMME]->Programme
- MajorProgramme-[:OF_YEAR]->Year
- Year-[:HAS_DOCUMENT]->Document
- Year-[:HAS_MAJORPROGRAMME]->MajorProgramme
- Programme-[:HAS_TUITION]->Tuition
- Tuition-[:OF_PROGRAMME]->Programme, Tuition-[:OF_YEAR]->Year
- Scholarship-[:OF_YEAR]->Year

==== II. LUẬT TẠO CYPHER ====
1. KHÔNG đưa từ viết tắt vào Cypher (VD: cntt -> công nghệ thông tin).
2. Nếu không có năm -> mặc định dùng năm hiện tại.
3. Dùng toán tử:
   apoc.text.clean(toLower(...)) CONTAINS apoc.text.clean(toLower('<keyword>'))
4. Nếu keyword là cụm dài (≥3 từ) -> tách nhỏ và OR từng phần.
5. Luôn DISTINCT, LIMIT để loại trùng.
6. KHÔNG dùng toán tử số (regex, split, parse...) để xử lý giá trị học phí.
7. Không dùng lại alias đã khai báo ở WITH/MATCH trước đó.
8. WHERE chỉ nên dùng sau MATCH, không dùng sau OPTIONAL MATCH nếu node có thể null.
9. Tránh sử dụng các lệnh WITH không cần thiết.
10. Chỉ sử dụng các hàm có trong schema thực tế (ví dụ: apoc.text.clean).
11. Nếu truy vấn phức tạp, hãy chia nhỏ thành nhiều phần, mỗi phần một MATCH/OPTIONAL MATCH rõ ràng.
12. Đảm bảo câu truy vấn không bị lỗi cú pháp, không bị trùng alias, và có thể chạy được trên Neo4j.
13. Nếu có nhiều điều kiện, hãy nhóm chúng hợp lý và kiểm tra lại logic.

==== III. CÁC TÌNH HUỐNG TIÊU BIỂU ====
1. Học phí:
MATCH (t:Tuition)-[:OF_YEAR]->(y:Year)
MATCH (t)-[:OF_PROGRAMME]->(p:Programme)
WHERE apoc.text.clean(toLower(t.content)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   OR apoc.text.clean(toLower(t.name)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   AND y.name = '<year>'
RETURN y.name, p.name, t.name, t.content, t.url
ORDER BY p.name LIMIT 20

2. Học bổng:
MATCH (s:Scholarship)-[:OF_YEAR]->(y:Year)
WHERE apoc.text.clean(toLower(s.name)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   OR apoc.text.clean(toLower(s.content)) CONTAINS apoc.text.clean(toLower('<keyword>'))
RETURN y.name, s.name, s.url, s.content LIMIT 20

3. Tài liệu:
MATCH (y:Year)-[:HAS_DOCUMENT]->(d:Document)
WHERE apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('<keyword>'))
RETURN y.name, d.name, d.url, d.type, d.text LIMIT 20

4. Thông tin ngành:
MATCH (m:Major)-[:HAS_PROGRAMME]->(p:Programme)<-[:OF_PROGRAMME]-(mp:MajorProgramme)-[:OF_MAJOR]->(m)
MATCH (mp)-[:OF_YEAR]->(y:Year)
WHERE apoc.text.clean(toLower(m.name)) CONTAINS apoc.text.clean(toLower('<major_kw>'))
   AND apoc.text.clean(toLower(p.name)) CONTAINS apoc.text.clean(toLower('<programme_kw>'))
   AND y.name = '<year>'
RETURN p, m, mp, y LIMIT 20

4b. Khi keyword chứa nhiều thông tin (ví dụ: “điểm chuẩn ngành ngôn ngữ anh”), hãy:
- Tách keyword thành các phần chính: loại thông tin (“điểm chuẩn”), tên đối tượng (“ngôn ngữ anh”).
- Ưu tiên tạo điều kiện WHERE với từng phần, kết hợp AND hoặc OR hợp lý:
- Từ khóa chính (loại thông tin) thường dùng AND với tên đối tượng.
- Các từ đồng nghĩa hoặc biến thể của cùng ý nghĩa dùng OR.
- Không lặp lại nguyên câu dài nhiều lần. Chỉ giữ các cụm cần thiết để tránh query rườm rà và không khớp dữ liệu.
- Ví dụ: “điểm chuẩn ngành ngôn ngữ anh” ->
WHERE apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('điểm chuẩn'))
   AND (
      apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('ngôn ngữ anh'))
   )

==== IV. LƯU Ý THÊM ====
- Nếu câu hỏi mang tính tư vấn ("nên học gì?", "tư vấn giúp") -> truy vấn Major, Programme hoặc MajorProgramme kèm gợi ý.
- Nếu không chắc truy vấn được node nào -> fallback tìm trong Document.
- Nếu trong lịch sử user nói rõ ngành/hệ, nhưng câu hỏi follow-up không lặp lại -> suy luận từ <chat_history> và dùng làm điều kiện.
- Bạn có thể dựa vào lịch sử trò chuyện của người dùng để có cái nhìn rộng hơn về ngữ cảnh để trả lời câu hỏi.

=== V. QUAN TRỌNG ===
- MajorProgramme.major_code là mã tuyển sinh CHUẨN, KHÔNG dùng Major.id.
- Hãy suy nghĩ như người hiểu rõ cấu trúc graph và logic tư vấn tuyển sinh.
- Khi truy vấn học phí dạng text, KHÔNG cố gắng chuyển đổi hoặc parse số trong Cypher.
- KHÔNG dùng toInteger, apoc.number.parseInt, hoặc các hàm chuyển đổi kiểu số trong Cypher.
- KHÔNG dùng các hàm đặc biệt có thể không hỗ trợ cho Neo4j hiện tại như size()...

=== THÔNG TIN BỔ SUNG ===
- Document chứa tài liệu về ĐIỂM CHUẨN CÁC NGÀNH
- Document chứa tài liểu về THÔNG TIN TRƯỜNG HỌC

=== ADAPTIVE QUERY GENERATION ===
**Phân tích previous enrichments:**
1. Nếu step trước query Major nhưng 0 results -> thử MajorProgramme hoặc Document
2. Nếu step trước query với keyword cụ thể -> thử keyword tổng quát hơn
3. Nếu step trước query 1 node type -> thử node type khác
4. Nếu context score không cải thiện -> đổi hoàn toàn approach

**Ví dụ adaptive strategies:**
- Query 1: MATCH (m:Major) WHERE ... → 0 results
- Query 2: MATCH (d:Document) WHERE ... → different approach
- Query 3: MATCH (mp:MajorProgramme) WHERE ... → another angle

**Đảm bảo diversity:**
- Mỗi enrichment PHẢI khác biệt về: node types, relationships, keywords, hoặc approach
- Không repeat exact same pattern với chỉ thay đổi minor details

Trả về JSON:
{
    "shouldEnrich": true/false,
    "reasoning": "Lý do cần/không cần enrichment + phân tích previous attempts",
    "purpose": "Mục đích cụ thể của query này",
    "cypher": "MATCH ... RETURN ... LIMIT 10",
    "expectedValue": "Giá trị dự kiến từ query này",
    "infoType": "scholarship|career|requirements|comparison|documents",
    "differenceFromPrevious": "Giải thích tại sao query này khác với các query trước"
}