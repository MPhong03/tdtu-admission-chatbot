ENRICHMENT PLANNING (Bước <step>/<max_steps>):

Câu hỏi gốc: "<user_question>"
Main context: <context_count> nodes
Analysis: <analysis_info>
Sample context: <sample_context>

Enrichment targets: <enrichment_targets>

QUY TẮC ENRICHMENT:
1. Chỉ tạo query khi THỰC SỰ cần thiết
2. Không duplicate với main context
3. Focus vào info gaps cho intent chính
4. Query phải valid theo Neo4j schema
5. Lưu ý quan trọng với học phí:
   - Không cố parse số từ t.content bằng split, filter, hay regex.
   - Không dùng ORDER BY dựa trên giá trị ước lượng học phí.
   - Chỉ cần truy vấn tài liệu học phí (Tuition) kèm tên hệ đào tạo và năm để người dùng đọc so sánh.
   - Dùng ORDER BY p.name để sắp xếp dễ nhìn.

ENRICHMENT SCENARIOS:
Main query về học phí -> Enrich với scholarship info
Comparison thiếu 1 side -> Complete comparison
Advice question thiếu decision factors -> Add career/market info
Main context đã đầy đủ -> Skip enrichment
Không liên quan intent -> Skip

QUY TẮC SINH CYPHER:
==== I. SCHEMA ĐỒ THỊ (TÓM TẮT) ====
Nodes:
- Major: Ngành học (VD: Khoa học máy tính).
- Programme: Hệ đào tạo (VD: Tiêu chuẩn, Tiên tiến).
- MajorProgramme: Tổ hợp Major + Programme theo năm.
- Tuition: Tài liệu học phí theo năm và hệ.
- Scholarship: Tài liệu học bổng.
- Document: Các tài liệu khác về trường.
- Year: Đại diện năm học.

Relationships:
- Major-[:HAS_PROGRAMME]->Programme
- Programme-[:HAS_MAJOR]->Major
- MajorProgramme-[:OF_MAJOR]->Major
- MajorProgramme-[:OF_PROGRAMME]->Programme
- MajorProgramme-[:OF_YEAR]->Year
- Year-[:HAS_DOCUMENT]->Document
- Year-[:HAS_MAJORPROGRAMME]->MajorProgramme
- Programme-[:HAS_TUITION]->Tuition
- Tuition-[:OF_PROGRAMME]->Programme, Tuition-[:OF_YEAR]->Year
- Scholarship-[:OF_YEAR]->Year

==== II. LUẬT TẠO CYPHER ====
1. KHÔNG dùng từ viết tắt (VD: cntt -> công nghệ thông tin).
2. Nếu không có năm -> mặc định dùng năm hiện tại.
3. Dùng toán tử:
   apoc.text.clean(toLower(...)) CONTAINS apoc.text.clean(toLower('<keyword>'))
4. Nếu keyword là cụm dài (≥3 từ) -> tách nhỏ và OR từng phần.
5. Luôn DISTINCT, LIMIT để loại trùng.
6. KHÔNG dùng toán tử số (regex, split, parse...) để xử lý giá trị học phí.
7. Không dùng lại alias đã khai báo ở WITH/MATCH trước đó.
8. WHERE chỉ nên dùng sau MATCH, không dùng sau OPTIONAL MATCH nếu node có thể null.
9. Tránh lồng nhiều WITH không cần thiết.
10. Chỉ sử dụng các hàm có trong schema thực tế (ví dụ: apoc.text.clean).
11. Nếu truy vấn phức tạp, hãy chia nhỏ thành nhiều phần, mỗi phần một MATCH/OPTIONAL MATCH rõ ràng.
12. Đảm bảo câu truy vấn không bị lỗi cú pháp, không bị trùng alias, và có thể chạy được trên Neo4j.
13. Nếu có nhiều điều kiện, hãy nhóm chúng hợp lý và kiểm tra lại logic.

==== III. CÁC TÌNH HUỐNG TIÊU BIỂU ====
1. Học phí:
MATCH (t:Tuition)-[:OF_YEAR]->(y:Year)
MATCH (t)-[:OF_PROGRAMME]->(p:Programme)
WHERE apoc.text.clean(toLower(t.content)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   OR apoc.text.clean(toLower(t.name)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   AND y.name = '<year>'
RETURN y.name, p.name, t.name, t.content, t.url
ORDER BY p.name LIMIT 20

2. Học bổng:
MATCH (s:Scholarship)-[:OF_YEAR]->(y:Year)
WHERE apoc.text.clean(toLower(s.name)) CONTAINS apoc.text.clean(toLower('<keyword>'))
   OR apoc.text.clean(toLower(s.content)) CONTAINS apoc.text.clean(toLower('<keyword>'))
RETURN y.name, s.name, s.url, s.content LIMIT 20

3. Tài liệu:
MATCH (y:Year)-[:HAS_DOCUMENT]->(d:Document)
WHERE apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('<keyword>'))
RETURN y.name, d.name, d.url, d.type, d.text LIMIT 20

4. Thông tin ngành:
MATCH (m:Major)-[:HAS_PROGRAMME]->(p:Programme)<-[:OF_PROGRAMME]-(mp:MajorProgramme)-[:OF_MAJOR]->(m)
MATCH (mp)-[:OF_YEAR]->(y:Year)
WHERE apoc.text.clean(toLower(m.name)) CONTAINS apoc.text.clean(toLower('<major_kw>'))
   AND apoc.text.clean(toLower(p.name)) CONTAINS apoc.text.clean(toLower('<programme_kw>'))
   AND y.name = '<year>'
RETURN p, m, mp, y LIMIT 20

4b. Khi keyword chứa nhiều thông tin (ví dụ: “điểm chuẩn ngành ngôn ngữ anh”), hãy:
- Tách keyword thành các phần chính: loại thông tin (“điểm chuẩn”), tên đối tượng (“ngôn ngữ anh”).
- Ưu tiên tạo điều kiện WHERE với từng phần, kết hợp AND hoặc OR hợp lý:
- Từ khóa chính (loại thông tin) thường dùng AND với tên đối tượng.
- Các từ đồng nghĩa hoặc biến thể của cùng ý nghĩa dùng OR.
- Không lặp lại nguyên câu dài nhiều lần. Chỉ giữ các cụm cần thiết để tránh query rườm rà và không khớp dữ liệu.
- Ví dụ: “điểm chuẩn ngành ngôn ngữ anh” ->
WHERE apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('điểm chuẩn'))
   AND (
      apoc.text.clean(toLower(d.text)) CONTAINS apoc.text.clean(toLower('ngôn ngữ anh'))
   )

==== IV. LƯU Ý THÊM ====
- Nếu câu hỏi mang tính tư vấn ("nên học gì?", "tư vấn giúp") -> truy vấn Major, Programme hoặc MajorProgramme kèm gợi ý.
- Nếu không chắc truy vấn được node nào -> fallback tìm trong Document.
- Nếu trong lịch sử user nói rõ ngành/hệ, nhưng câu hỏi follow-up không lặp lại -> suy luận từ <chat_history> và dùng làm điều kiện.
- Bạn có thể dựa vào lịch sử trò chuyện của người dùng để có cái nhìn rộng hơn về ngữ cảnh để trả lời câu hỏi.

=== V. QUAN TRỌNG ===
- MajorProgramme.major_code là mã tuyển sinh CHUẨN, KHÔNG dùng Major.id.
- Hãy suy nghĩ như người hiểu rõ cấu trúc graph và logic tư vấn tuyển sinh.
- Khi truy vấn học phí dạng text, KHÔNG cố gắng chuyển đổi hoặc parse số trong Cypher.
- KHÔNG dùng toInteger, apoc.number.parseInt, hoặc các hàm chuyển đổi kiểu số trong Cypher.
- KHÔNG dùng các hàm đặc biệt có thể không hỗ trợ cho Neo4j hiện tại như size()...

=== THÔNG TIN BỔ SUNG ===
- Document chứa tài liệu về ĐIỂM CHUẨN CÁC NGÀNH
- Document chứa tài liểu về THÔNG TIN TRƯỜNG HỌC

Trả về JSON:
{
    "shouldEnrich": true/false,
    "reasoning": "Lý do cần/không cần enrichment",
    "purpose": "Mục đích cụ thể của query",
    "cypher": "MATCH ... RETURN ... LIMIT 10",
    "expectedValue": "Giá trị dự kiến",
    "infoType": "scholarship|career|requirements|comparison"
}